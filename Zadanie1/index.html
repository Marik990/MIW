<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Zadanie 1</title>

    <link rel="stylesheet" href="css/main.css" type="text/css">

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>
<body>
    <header>
        <div id="title">Zadanie 1</div>
    </header>
    <main>
        <article>
            <section>
                <div id="upload-data">
                    <form id="upload-data-form">
                        <label>
                            Wybierz plik z danymi:
                        </label>
                        <input id="data-file" type="file" name="dataFile">
                        <input id="upload-data-btn" type="button" value="Uruchom">
                    </form>
                </div>

                <div id="upload-config">
                    <form id="config-data-form">
                        <label>
                            Załaduj plik konfiguracyjny:
                        </label>
                        <input id="config-file" type="file" name="configFile" style="padding-bottom: 10px">
                        <input id="upload-config-btn" type="button" value="Załaduj">
                    </form>
                </div>
            </section>
            <section>
                <div id="board">

                </div>
            </section>
            <div id="back-btn">
                <button>Wróć</button>
            </div>
        </article>
    </main>

<script>

    /*
    możliwe rodzaje atrybutów: int, float, symbol, decision

    uwaga do skryptu: wartości typu symbol są normalizowane inaczej niż wartości numeryczne
                      wartości numeryczne są normalizowane według minimalnych i maksymalnych wartości obecnych w tabeli(niezależnie od możliwego zakresu w Config.ValuesScopes)
                      wartości symboliczne są normalizowane według ilości możliwych symboli dla danej kolumny zawartych w Config.ValuesScopes
     */

    const Config = {
        AttributesSeparator: ",",
        RowsSeparator: "\n",
        MissingValuesSymbol: "?",
        NumberOfAttributes: 16,
        ColumnTypes: [  "symbol", "float", "float", "symbol", "symbol",
                        "symbol", "symbol", "float", "symbol", "symbol",
                        "float", "symbol", "symbol", "int", "int",
                        "decision"],
        ValuesScopes: [
            ["b", "a"],
            [0, 100],
            [0, 100],
            ["u", "y", "l", "t"],
            ["g", "p", "gg"],

            ["c", "d", "cc", "i", "j", "k", "m", "r", "q", "w", "x", "e", "aa", "ff"],
            ["v", "h", "bb", "j", "n", "z", "dd", "ff", "o"],
            [0, 100],
            ["t", "f"],
            ["t", "f"],

            [0, 100],
            ["t", "f"],
            ["g", "p", "s"],
            [0, 99999],
            [0, 999999],

            ["+", "-"]
        ],
        NormalizationScope: [0, 1, 2],
        Ready: true
    }

    function processConfigFile(rawConfig) {
        //napisać proces przetwarzania pliku konfiguracyjnego przy pomocy surowych danych
    }

    function processDataFileContent(rawFileContent) {
        try {
            const dataSet = createDataSet(rawFileContent)
            checkDataSetIntegrity(dataSet)
            const normalizedDataSet = normalizeDataSet(dataSet)

            displayDataSet(normalizedDataSet)
        }
        catch (e) {
            alert(`Błąd: ${e.message}`)
            document.getElementById('upload-data-form').reset()
            document.getElementById('board').innerText = ""
            throw new Error(`${e.message}`)
        }
    }

    function createDataSet(rawData) {
        if(rawData.length <= 0)
            throw new Error("Plik z danymi jest pusty!")

        const lines = separateLines(rawData)
        const dataSet = separateAttributes(lines)

        return dataSet
    }
    
    function separateLines(rawData) {
        let lines = []
        if(Config.RowsSeparator === '\n' || Config.RowsSeparator === '\r') {
            for (let i = 0, startNewLineIndex = 0; i < rawData.length; i++) {
                if (rawData.charAt(i) === '\n' || rawData.charAt(i) === '\r') {
                    lines.push(rawData.substring(startNewLineIndex, i))
                    if (rawData.charAt(i+1) === '\n' || rawData.charAt(i+1) === '\r')
                        i++
                    startNewLineIndex = i + 1
                }
            }
        }
        else {
            for (let i = 0, startNewLineIndex = 0; i < rawData.length; i++) {
                if (rawData.charAt(i) === Config.RowsSeparator) {
                    lines.push(rawData.substring(startNewLineIndex, i))
                    startNewLineIndex = i + 1
                }
            }
        }

        if(lines.length <= 0)
            throw new Error("Nie udało się wydzielić ani jednego rekordu! Pamiętaj, że rekordy muszą być zakończone separatorem rekordów zdefiniowanym w pliku konfiguracyjnym.")

        return lines
    }
    
    function separateAttributes(dataLines) {
        let dataSet = []
        for (let i = 0; i < dataLines.length; i++) {
            let dataRow = []
            for (let j = 0, k = 0; j < dataLines[i].length; j++) {
                if (dataLines[i].charAt(j) === Config.AttributesSeparator) {
                    k++
                    continue
                }
                if (dataRow[k]) {
                    dataRow[k] += dataLines[i].charAt(j)
                } else {
                    dataRow[k] = dataLines[i].charAt(j)
                }
            }
            if(dataRow.length > 0)
                dataSet.push(dataRow)
        }
        if(dataSet.length <= 0)
            throw new Error("Nie udało się wydzielić ani jednego rekordu! Pamiętaj, że separator atrybutów jest symbolem pomijanym w trakcie odczytywania danych, możesz go zdefiniować w pliku konfiguracyjnym.")

        return dataSet
    }
    
    function checkDataSetIntegrity(dataSet) {
        checkNumberOfAttributes(dataSet)
        validateAttributesTypes(dataSet)
        validateValuesScopes(dataSet)
    }

    function checkNumberOfAttributes(dataSet) {
        for(let i = 0; i < dataSet.length; i++) {
            if(dataSet[i].length !== Config.NumberOfAttributes)
                throw new Error(`Liczba atrybutów w rekordzie ${i+1} jest nieprawidłowa!`)
        }
    }
    
    function validateAttributesTypes(dataSet) {
        for(let i = 0; i < dataSet.length; i++) {
            for(let j = 0; j < dataSet[i].length; j++) {
                if(dataSet[i][j] === Config.MissingValuesSymbol) {

                }
                else if(Config.ColumnTypes[j] === "float" && isAttributeFloat(dataSet[i][j])) {
                    dataSet[i][j] = parseFloat(dataSet[i][j])
                }
                else if(Config.ColumnTypes[j] === "int" && isAttributeInt(dataSet[i][j])) {
                    dataSet[i][j] = parseInt(dataSet[i][j])
                }
                else if(Config.ColumnTypes[j] === "symbol" || Config.ColumnTypes[j] === "decision") {

                }
                else {
                    throw new Error(`Niewłaściwy typ atrybutu ${j+1} w rekordzie ${i+1}`)
                }
            }
        }
    }

    function isAttributeFloat(attribute) {
        return (!isNaN(attribute) && !isNaN(parseFloat(attribute)))
    }
    
    function isAttributeInt(attribute) {
        return (!isNaN(attribute) && !isNaN(parseInt(attribute)) && Number.isInteger(parseFloat(attribute)))
    }

    function validateValuesScopes(dataSet) {
        for(let i = 0; i < dataSet.length; i++) {
            for(let j = 0; j < dataSet[i].length; j++) {
                if(dataSet[i][j] === Config.MissingValuesSymbol) {

                }
                else if(typeof dataSet[i][j] === "number") {
                    if(dataSet[i][j] < Config.ValuesScopes[j][0] || dataSet[i][j] > Config.ValuesScopes[j][1])
                        throw new Error(`Wartość atrybutu ${j+1} w rekordzie ${i+1} nie mieści się w podanym zakresie!`)
                }
                else if(typeof dataSet[i][j] === "string") {
                    let valueDetected = 0
                    for(let k = 0; k < Config.ValuesScopes[j].length; k++) {
                        if(dataSet[i][j] === Config.ValuesScopes[j][k]) {
                            valueDetected = 1
                            break
                        }
                    }
                    if(!valueDetected) {
                        throw new Error(`Wartość atrybutu ${j+1} w rekordzie ${i+1} nie mieści się w podanym zakresie!`)
                    }
                }
                else {
                    throw new Error(`Atrybut ${j+1} w rekordzie ${i+1} spowodował nieoczekiwany błąd w trakcie walidacji zakresu!`)
                }
            }
        }
    }
    
    function normalizeDataSet(dataSet) {
        let normalizedDataSet = []
        for(let i = 0; i < dataSet.length; i++) {
            normalizedDataSet.push(dataSet[i].slice(0))
        }
        normalizeNumbers(normalizedDataSet)
        normalizeSymbols(normalizedDataSet)

        return normalizedDataSet
    }
    
    function normalizeNumbers(normalizedDataSet) {
        for(let i = 0; i < Config.ColumnTypes.length; i++) {
            if (Config.ColumnTypes[i] === "float" || Config.ColumnTypes[i] === "int") {
                for (let j = 0; j < normalizedDataSet.length; j++) {
                    if(normalizedDataSet[j][i] === Config.MissingValuesSymbol) {
                        alert("Ostrzeżenie: Wykryto brakujące wartości typu liczbowego! W procesie normalizacji zostaną one zamienione na medianę.")
                        i = Config.ColumnTypes.length
                        break;
                    }
                }
            }
        }

        let sortedValues
        let maxValue
        let minValue
        for(let icol = 0; icol < Config.ColumnTypes.length; icol++) {
            if(Config.ColumnTypes[icol] === "float" || Config.ColumnTypes[icol] === "int") {
                sortedValues = []
                for(let irow = 0; irow < normalizedDataSet.length; irow++) {
                    if(normalizedDataSet[irow][icol] === Config.MissingValuesSymbol) {
                        continue
                    }
                    sortedValues.push(normalizedDataSet[irow][icol])
                }
                sortedValues.sort(function(a, b){return a-b})
                for(let irow = 0; irow < normalizedDataSet.length; irow++) {
                    if(normalizedDataSet[irow][icol] === Config.MissingValuesSymbol) {
                        normalizedDataSet[irow][icol] = sortedValues[parseInt((sortedValues.length - 1) / 2)]
                    }
                }
                minValue = sortedValues[0]
                maxValue = sortedValues[sortedValues.length - 1]
                for(let irow = 0; irow < normalizedDataSet.length; irow++) {
                        normalizedDataSet[irow][icol] = (normalizedDataSet[irow][icol]-minValue) / (maxValue-minValue)    //wzór na nrmalizację numeryczną w zakresie 0:1
                        normalizedDataSet[irow][icol] = (normalizedDataSet[irow][icol] * (Config.NormalizationScope[1] - Config.NormalizationScope[0])) + Config.NormalizationScope[0] //dodatkowy wzór przekształacający normalizację 0:1 do podanego zakresu

                        let roundNumber = 1
                        if(Config.NormalizationScope[2] > 0) {
                            for(let i = 0; i < Config.NormalizationScope[2]; i++)
                                roundNumber *= 10
                        }
                        normalizedDataSet[irow][icol] = Math.round((normalizedDataSet[irow][icol] + Number.EPSILON) * roundNumber) / roundNumber
                }
            }
        }
    }
    
    function normalizeSymbols(normalizedDataSet) {
        //wykryj brakujące wartości
        for(let i = 0; i < Config.ColumnTypes.length; i++) {
            if (Config.ColumnTypes[i] === "symbol") {
                for (let j = 0; j < normalizedDataSet.length; j++) {
                    if(normalizedDataSet[j][i] === Config.MissingValuesSymbol) {
                        alert("Ostrzeżenie: Wykryto brakujące wartości typu symbol! W procesie normalizacji zostaną one zamienione na wartości występujące najczęściej.")
                        i = Config.ColumnTypes.length
                        break;
                    }
                }
            }
        }

        //uzupełnij brakujące wartości
        let columnArray = []
        let mostFrequentItem
        for(let i = 0; i < Config.ColumnTypes.length; i++) {
            if (Config.ColumnTypes[i] === "symbol") {
                for (let j = 0; j < normalizedDataSet.length; j++) {
                    if(normalizedDataSet[j][i] === Config.MissingValuesSymbol) {
                        continue
                    }
                    columnArray.push(normalizedDataSet[j][i])
                }
                mostFrequentItem = findMostFrequentItemInArray(columnArray)
                for (let j = 0; j < normalizedDataSet.length; j++) {
                    if(normalizedDataSet[j][i] === Config.MissingValuesSymbol) {
                        normalizedDataSet[j][i] = mostFrequentItem
                    }
                }
            }
            columnArray = []
        }

        //zamień wszystkie wartości na liczby
        for(let i = 0; i < Config.ColumnTypes.length; i++) {
            if (Config.ColumnTypes[i] === "symbol") {
                for (let j = 0; j < Config.ValuesScopes[i].length; j++) {
                    for(let k = 0; k < normalizedDataSet.length; k++) {
                        if(normalizedDataSet[k][i] === Config.ValuesScopes[i][j]) {
                            normalizedDataSet[k][i] = j
                        }
                    }
                }
            }
        }

        //znormalizuj wartości
        let maxValue
        let minValue
        for(let icol = 0; icol < Config.ColumnTypes.length; icol++) {
            if (Config.ColumnTypes[icol] === "symbol") {
                minValue = 0
                maxValue = Config.ValuesScopes[icol].length - 1
                for(let irow = 0; irow < normalizedDataSet.length; irow++) {
                    normalizedDataSet[irow][icol] = (normalizedDataSet[irow][icol]-minValue) / (maxValue-minValue)    //wzór na nrmalizację numeryczną w zakresie 0:1
                    normalizedDataSet[irow][icol] = (normalizedDataSet[irow][icol] * (Config.NormalizationScope[1] - Config.NormalizationScope[0])) + Config.NormalizationScope[0] //dodatkowy wzór przekształacający normalizację 0:1 do podanego zakresu

                    let roundNumber = 1
                    if(Config.NormalizationScope[2] > 0) {
                        for(let i = 0; i < Config.NormalizationScope[2]; i++)
                            roundNumber *= 10
                    }
                    normalizedDataSet[irow][icol] = Math.round((normalizedDataSet[irow][icol] + Number.EPSILON) * roundNumber) / roundNumber
                }
            }
        }
    }

    function findMostFrequentItemInArray(arr){
        let newArray = arr.slice()

        return newArray.sort((a,b) =>
            newArray.filter(v => v===a).length
            - newArray.filter(v => v===b).length
        ).pop();
    }

    /*
    To Do List:
    - przetwarzanie pliku konfiguracyjnego
    - zapis znormalizowanych danych do pliku
     */

</script>
    <script src="additionalScripts.js" type="text/javascript"></script>
</body>
</html>